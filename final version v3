#include "stm32f4xx.h"
#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>

#define I2C1_PORT I2C1
#define LCD_ADDR (0x27 << 1) 
#define LCD_EN_PIN (1U << 2) 
#define LCD_BL_PIN (1U << 3) 
#define LCD_RS_CMD 0 
#define LCD_RS_DATA (1U << 0) 

#define IR_PIN    (1U << 0)
#define IR_PORT   GPIOA

#define RESET_BTN_PIN (1U << 12)
#define RESET_BTN_PORT GPIOC 

#define SERVO_PIN (1U << 7)
#define SERVO_PORT GPIOC
#define SERVO_TIM TIM3

#define SERVO_PSC  15    
#define SERVO_ARR  19999 
#define SERVO_CLOSED_PULSE 1700
#define SERVO_OPEN_PULSE   2200

volatile int feed_count_remaining = 3; 
volatile bool is_locked_out = false; 

void delay_ms(volatile uint32_t ms) {
    for (uint32_t i = 0; i < ms * 3200; i++) __NOP();
}

void delay_us(volatile uint32_t us) {
    us *= 5; 
    while (us--) __NOP();
}

void I2C1_Init(void) {
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOBEN;
    RCC->APB1ENR |= RCC_APB1ENR_I2C1EN;
    GPIOB->MODER |= (2U << 16 | 2U << 18);
    GPIOB->OTYPER |= (1U << 8) | (1U << 9);
    GPIOB->PUPDR |= (1U << 16 | 1U << 18);
    GPIOB->AFR[1] |= (4U << 0) | (4U << 4);
    I2C1_PORT->CR1 &= ~I2C_CR1_PE; 
    I2C1_PORT->CR2 = 16; 
    I2C1_PORT->CCR = 80; 
    I2C1_PORT->TRISE = 17; 
    I2C1_PORT->CR1 |= I2C_CR1_PE; 
}

uint8_t i2c_write(uint8_t address, uint8_t data) {
    I2C1_PORT->CR1 |= I2C_CR1_START;
    while (!(I2C1_PORT->SR1 & I2C_SR1_SB));
    I2C1_PORT->DR = address;
    while (!(I2C1_PORT->SR1 & I2C_SR1_ADDR));
    (void)I2C1_PORT->SR2;
    I2C1_PORT->DR = data;
    while (!(I2C1_PORT->SR1 & I2C_SR1_BTF));
    I2C1_PORT->CR1 |= I2C_CR1_STOP;
    return 1;
}

void lcd_send(uint8_t val, uint8_t mode) {
    uint8_t d = val | mode | LCD_BL_PIN; 
    i2c_write(LCD_ADDR, d | LCD_EN_PIN);
    delay_us(100); 
    i2c_write(LCD_ADDR, d & ~LCD_EN_PIN);
    delay_us(100); 
}

void lcd_cmd(uint8_t cmd) {
    lcd_send(cmd & 0xF0, LCD_RS_CMD);
    lcd_send((cmd << 4) & 0xF0, LCD_RS_CMD);
}

void lcd_data(uint8_t data) {
    lcd_send(data & 0xF0, LCD_RS_DATA);
    lcd_send((data << 4) & 0xF0, LCD_RS_DATA);
}

void lcd_init(void) {
    delay_ms(300); 
    lcd_send(0x30, 0); delay_ms(5); 
    lcd_send(0x30, 0); delay_us(100); 
    lcd_send(0x30, 0); delay_us(100); 
    lcd_send(0x20, 0); 
    lcd_cmd(0x28); lcd_cmd(0x08); lcd_cmd(0x01); 
    delay_ms(2); lcd_cmd(0x06); lcd_cmd(0x0C); 
}

void update_lcd_display(void) {
    char buf[17]; 
    lcd_cmd(0x80);
    char *title = "Cat Feeder Count";
    while(*title) lcd_data(*title++);
    lcd_cmd(0xC0);
    if (feed_count_remaining > 0) sprintf(buf, "Left: %d times    ", feed_count_remaining);
    else sprintf(buf, "LIMIT REACHED!  ");
    char *p = buf;
    while(*p) lcd_data(*p++);
}

void Servo_Init(void) {
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOCEN;
    RCC->APB1ENR |= RCC_APB1ENR_TIM3EN;
    SERVO_PORT->MODER |= (2U << 14); 
    SERVO_PORT->AFR[0] |= (2U << 28);   
    SERVO_TIM->PSC = SERVO_PSC; 
    SERVO_TIM->ARR = SERVO_ARR; 
    SERVO_TIM->CCMR1 |= (6U << 12) | TIM_CCMR1_OC2PE; 
    SERVO_TIM->CCER |= TIM_CCER_CC2E;
    SERVO_TIM->CR1 |= TIM_CR1_CEN;
}

void Reset_Button_EXTI_Init(void) {
    RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
    SYSCFG->EXTICR[3] &= ~(0xF << 0);
    SYSCFG->EXTICR[3] |= (0x2 << 0);
    EXTI->IMR |= (1U << 12);
    EXTI->FTSR |= (1U << 12);
    NVIC_EnableIRQ(EXTI15_10_IRQn);
}

void EXTI15_10_IRQHandler(void) {
    if (EXTI->PR & (1U << 12)) {
        EXTI->PR = (1U << 12);
        feed_count_remaining = 3;
        update_lcd_display();
    }
}

int main(void) {
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN | RCC_AHB1ENR_GPIOCEN;
    IR_PORT->MODER &= ~(3U << 0);
    RESET_BTN_PORT->MODER &= ~(3U << 24); 
    RESET_BTN_PORT->PUPDR |= (1U << 24);

    Reset_Button_EXTI_Init();
    Servo_Init(); I2C1_Init(); lcd_init();
    SERVO_TIM->CCR2 = SERVO_CLOSED_PULSE;
    update_lcd_display(); 

    while (1) {
        if (!(IR_PORT->IDR & IR_PIN)) {
            if (feed_count_remaining > 0 && !is_locked_out) {
                feed_count_remaining--; 
                is_locked_out = true; 
                SERVO_TIM->CCR2 = SERVO_OPEN_PULSE; 
                delay_ms(400); 
                SERVO_TIM->CCR2 = SERVO_CLOSED_PULSE; 
                update_lcd_display(); 
                delay_ms(500); 
            }
        } else {
            is_locked_out = false;
        }
        delay_ms(50); 
    }
}
